## Copy

```c++
#include <iostream>
#include <vector> // std::vector 为 C++ 中长度可变的数组，初始化时默认所有值为 0

int main(void)
{
	int n, m;
	std::cin >> n >> m;

    // std::vector 的二维数组，详见 https://zhuanlan.zhihu.com/p/715548933
    std::vector<std::vector<char>> a(n + 1, std::vector<char>(m + 1));
    // 让数组的范围扩大一格，不使用第 0 个位置会让逻辑更清晰
    std::vector<std::vector<char>> b(2 * n + 1, std::vector<char>(2 * m + 1));

	for (int i(1); i <= n; i++)
    {
        for (int j(1); j <= m; j++)
        {
            std::cin >> a[i][j];
        }
    }
    
	for(int i(1); i <= n; i++)
    {
        for (int j(1); j <= m; j++)
        {
            b[2 * i - 1][2 * j - 1] = a[i][j];
            b[2 * i]    [2 * j - 1] = a[i][j];
            b[2 * i - 1][2 * j]     = a[i][j];
            b[2 * i]    [2 * j]     = a[i][j];
        }
    }
    for (int i(1); i <= 2 * n; i++)
	{
		for (int j(1); j <= 2 * m; j++)
        {
            std::cout << b[i][j];
        }
        std::cout << std::endl;
	}
	return 0;
}
```

## Fibonacci数列

```c++
// 递归求法（自顶向下）
#include <iostream>

int solve(int n); // 递归求各级楼梯走法

int main(void)
{
    int n;
    std::cin >> n;
    std::cout << solve(n) << std::endl;
    return 0;
}

int solve(int n)
{
    if (n == 0) 
        return 0;
    if (n == 1)
        return 1;
    return solve(n - 1) + solve(n - 2); 
}



// 动态规划求法（自底向上）
#include <iostream>
#include <vector> // std::vector 为 C++ 中长度可变的数组，初始化时默认所有值为 0

int main(void)
{
    int n;
    std::cin >> n;
    std::vector<int> anss(n + 1);
    anss[0] = 0;
    anss[1] = 1;
    for (int i(2); i <= n; ++i)
    {
        anss[i] = anss[i - 1] + anss[i - 2];
    }
    std::cout << anss[n] << std::endl;
    return 0;
}
```

## 超级楼梯

```c++
// 递归求法（自顶向下）
#include <iostream>

int solve(int n); // 递归求各级楼梯走法

int main(void)
{
    int m;
    std::cin >> m;
    std::cout << solve(m) << std::endl;
    return 0;
}

int solve(int n)
{
    if (n == 2) // 1 + 1 = 2
        return 1;
    if (n == 3) // 1 + 2 = 3 || 2 + 1 = 3
        return 2;
    return solve(n - 1) + solve(n - 2); // (n - 1) + 1 = n || (n - 2) + 2 = n
}



// 动态规划求法（自底向上）
#include <iostream>
#include <vector> // std::vector 为 C++ 中长度可变的数组，初始化时默认所有值为 0

int main(void)
{
    int m;
    std::cin >> m;
    std::vector<int> anss(m + 1);
    anss[2] = 1;
    anss[3] = 2;
    for (int i(4); i <= m; ++i)
    {
        anss[i] = anss[i - 1] + anss[i - 2];
    }
    std::cout << anss[m] << std::endl;
    return 0;
}
```

## 过滤多余的空格

```c++
#include <iostream>

int main(void)
{
    std::string s;
    std::getline(std::cin, s); // 句子中有空格，需要使用读取一行字符的函数，C 语言对应 gets(s)
    int n(s.size()); // 求字符串长度，C 语言对应 string.h 中的 strlen(s)
    
    // 布尔值，用于判断是否输出空格，C 语言中可用 int 型的 0 和 1 代替
    bool out(true); // 实际上这里初始化为什么都无所谓的

    for (int i(0); i < n; ++i)
    {
        if (s[i] == ' ')
        {
            if (out == true)
            {
                std::cout << s[i];
                out = false; // 已经输出一个空格，如果下一个字符仍是空格则不输出}
            }
        }
        else
        {
            std::cout << s[i];
            out = true; // 当前位置不是空格，则以后出现的第一个空格可以输出
        }
    }
    std::cout << std::endl;
    return 0;
}
```

## 幂次方

```c++
#include <iostream>

int main(void)
{
    int n;
    std::cin >> n;

    // 布尔值，用于判断是否输出空格，C 语言中可用 int 型的 0 和 1 代替
    bool add(false); // 判断是否需要输出 “+”
    
    while (n)
    {
        if (add)
            std::cout << "+";

        int flag(0); // 2 的 flag 次方的值为 temp
        int temp(1);

        while (temp < n)
        {
            ++flag;
            temp *= 2;
        }

        if (temp > n)
        {
            std::cout << "2^" << flag - 1;
            n -= temp / 2;
        }
        else if (temp == n)
        {
            std::cout << "2^" << flag;
            n = 0;
        }
        
        // 输出过一个数之后，之后的数前面都需要加 “+”
        add = true;
    }
    std::cout << std::endl;
    return 0;
}
```

## 身份证排序

```c++
#include <iostream>
#include <vector> // std::vector 为 C++ 中长度可变的数组，初始化时默认所有值为 0
#include <algorithm> // 包含函数 std::sort()

struct ID // 对于每个身份证，将其全部号码和排列时的参考号码存在一起
{
    // std::string 为 C++ 中的字符串类，初始化默认为空字符串 ""
    std::string id; // 身份证位数太多，用字符串存储（long long也存的下就是了……）
    std::string flag;
};

bool cmp(ID a, ID b); // 自定义的排序规则

int main(void)
{
    int n;
    std::cin >> n;
    std::vector<ID> ids(n); 
    for (int i(0); i < n; ++i)
    {
        std::cin >> ids[i].id;
        for (int j(6); j <= 13; ++j) // 从完整身份证号码中提取出生日期
        {
            ids[i].flag += ids[i].id[j];
        }
    }

    // C++ 库中的排序函数（自己手搓冒泡排序啥的也可以，学长比较懒……）
    std::sort(ids.begin(), ids.end(), cmp); // 这里仅仅是一个排序，不一定用 std::sort()，想学的自己去搜索
    // 参数一：排序的起始位置
    // 参数二：排序的终止位置的后边一个位置 
    // ps：区间 [begin, end)
    // 参数三：自定义的排序规则

    for (int i(0); i < n; ++i) // 输出排序好的身份证
    {
        std::cout << ids[i].id << std::endl;
    }
    return 0;
}

bool cmp(ID a, ID b)
{
    return a.flag > b.flag; // 排序后按 flag 从大到小排序
}
```

## 十进制转m进制

```c++
#include <iostream>
#include <stack> // std::stack 为数据结构栈，后进先出（其他方法可以实现倒序输出亦可，例：递归）

int main(void)
{
    int n, m;
    std::cin >> n >> m;

    std::stack<char> k;
    while (n)
    {
        int mod(n % m);
        n /= m;
        if (mod < 10)
            k.push(mod + '0');
        else if (mod == 10)
            k.push('A');
        else if (mod == 11)
            k.push('B');
        else if (mod == 12)
            k.push('C');
        else if (mod == 13)
            k.push('D');
        else if (mod == 14)
            k.push('E');
        else if (mod == 15)
            k.push('F');
    }

    while (!k.empty()) // 倒序输出
    {
        std::cout << k.top(); // 输出栈顶元素
        k.pop(); //栈顶元素出栈
    }
    std::cout << std::endl;
    return 0;
}
```

## 输出字母图形

```c++
#include <iostream>

int main(void)
{
    char c;
    std::cin >> c;
    for (char i(c); i >= 'A'; --i) // 每行的最大字母
    {
        for (char j(c); j >= 'A'; --j) // 先倒序输出
        {
            if (j > i) // 每行最开始的空格
                std::cout << " ";
            else
                std::cout << j;
        }   
        for (char j('A'); j < i; ++j) // 再正序输出
        {
            std::cout << j;
        }
        std::cout << std::endl; // 输出完换行
    }
    return 0;
}
```

## 数对

```c++
#include <iostream>

int main(void)
{
    int n;
    std::cin >> n;
    for (int i(1); i <= n; ++i)
    {
        if (n % i == 0)
            std::cout << i << " * " << n / i << " = " << n << std::endl;
    }
    return 0;
}
```

## 统计单词数

```c++
#include <iostream>
#include <cctype>

int main(void)
{
    std::string s;
    std::getline(std::cin, s); // 句子中有空格，需要使用读取一行字符的函数，C 语言对应 gets(s)
    int n(s.size()); // 求字符串长度，C 语言对应 string.h 中的 strlen(s)

    int ans(0);
    for (int i(1); i < n; ++i)
    {
        // isalpha(c) 为判断 c 是否为英文字母，头文件为 C 语言的 ctype.h 或 C++ 的 cctype
        if (isalpha(s[i]) && s[i - 1] == ' ') // 除第一个单词外，每个单词前都有一个空格，统计这种组合的出现次数
            ++ans;
    }
    ans += 1; // 加上第一个单词

    std::cout << ans << std::endl;
    return 0;
}
```

## 子序列和

```c++
#include <iostream>
#include <vector> // std::vector 为 C++ 中长度可变的数组，初始化时默认所有值为 0

int main(void)
{
    int n, k;
    std::cin >> n >> k;
    std::vector<int> as(n); 
    for (int i(0); i < n; ++i) // int i(0) 意为初始化时将 i 赋值为 0（C++11 语法）
    {
        std::cin >> as[i];
    }
    for (int i(0); i < n; ++i) // 从各个位置开始往后遍历，检查是否存在连续的几个数和为 k
    {
        int sum(0);
        for (int j(i); j < n; ++j)
        {
            sum += as[j];
            if (sum == k) // 存在和为 k 的连续序列，输出 “yes” 并结束程序
            {
                std::cout << "yes" << std::endl;
                return 0;
            }
            else if (sum > k) // 连续序列和大于 k，跳出循环，节约时间
            {
                break;
            }
        }
    }
    std::cout << "no" << std::endl; // 没有找到和为 k 的连续序列，输出 “no”
    return 0;
}
```

## 最长上升子序列

```c++
// 经典的动态规划算法题，难度偏高，网上有视频教程
#include <iostream>
#include <vector> // std::vector 为 C++ 中长度可变的数组，初始化时默认所有值为 0

int main(void)
{
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    for (int i(0); i < n; ++i)
    {
        std::cin >> a[i];
    }

    // dp 意为动态规划，本数组用于记录从起始点到各个位置的最长子序列长度
    std::vector<int> dp(n, 1); // 初始化把每个位置的最长子序列长度设为 1，即只包含当前位置字符的序列
    for (int i(0); i < n; ++i)
    {
        for (int j(0); j < i; ++j)
        {
            if (a[i] > a[j]) // 对于每个位置 i，从前面寻找比 a[i] 小的数
                // 如果某个位置 j 数符合条件，dp[i] 为 dp[j] + 1 和 dp[i] 的最大值
                dp[i] = std::max(dp[i], dp[j] + 1);
        }
    }
    std::cout << dp[n - 1] << std::endl;
    return 0;
}
```

